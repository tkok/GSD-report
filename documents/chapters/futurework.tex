\section{Future Work \& Improvements}\label{subsec:improvements}
Though we have tried to make the policy engine as flexible as possible, some issues remain. For example, if we are having a policy that rolls down the blinds during the night, and we want them to roll up when the policy is no longer active (decided by the toTime property), it is not possible at the moment --- when just using a single policy. We can of course create a new policy that rolls up the blinds at a certain time in the morning.

As explained earlier, our expression language should be improved to allow multiple expressions with the choice of OR as opposed to the current AND-only functionality. With the GPL's\footnote{General Purpose Language} on the market today, people expect to be able to make complex conditions --- even though the users of the system are not IT experts. This could be accomplished by extending our expression language so it is recursion safe, or embedding an expression language inside our policy engine that is already recursion safe. The aforementioned nested statements should also be a possibility to create within the GUI. While we have taken the preliminary steps for this we did not have time to fully implement it.

We would also like to have made some enhancements to the SetStatement functionality, in particular \textit{temporal constraints --- Time} and \textit{State}. Explained shortly, \textit{Time} should be used in two ways. It should be able to conditionally query if the current time is within some specified interval. This could be used for making policies behave differently on certain times (for example, from 14:00 to 19:00 on Wednesdays). Time can be added relatively simple, as a basic-edition wrapper of the GregorianCalendar class. \textit{States} are thought to be boolean variables accessible globally and locally - dependent on which scope it was declared. This way, for example, a fire detection policy could set the \textit{buildingIsOnFire} state, and each other policy would be able to change it's behavior if needed based on access to that state. States can also be programmed easily, by having a map or a hashtable with key and boolean value pairs. The local states can be implemented by using the same structure for the global states, but with the policy id as a prefix in the name. Due to the project's time-constraints --- and the four missing resources that should have been available from Kenya --- we decided to forego of this nice-to-have functionality and focus our efforts elsewhere. 

Another improvement could be to have a policy analysis that validates the expressions. For instance in our implementation there can be two policies that manipulates the same elements, but one is doing one thing while another is doing another thing. Currently in the implementation what ever expression is executed last wins.

\section{Threats to Validity}\label{subsec:threatstovalidity}

\subsection{Internal Threats}
Selection: One of the internal threats are the group composition. We did not have any influence in who we were paired with from Kenya. The motivation, abilities and experience did prove to be very different within the two subgroups.

Experimental Mortality: Differential loss of participants across our group proved to affect the end result. We had three out of four Kenyans drop out. This put a lot more work on our shoulders and forced us to cut down on some features for instance the nested statements in the GUI.

\subsection{External Threats}


%%External validity refers to the degree to which the results of an empirical investigation can be generalized to and across individuals, settings, and times.
%%because we only tested on a simulator that its a huge threat to validity
