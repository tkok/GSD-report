\section{Front-end}
\label{sec:front-end}
\subsection{Initial Ideas}

The main idea for the user interface is to keep it simple and user-friendly without loosing advanced functionality. Initially we started making some rough drawings -so to better understand what we were dealing with. Doing so we tried to plan ahead how the visuals could look like, the functionally and how the user would be able to control the policy engine.

[insert initial drawings]

We quickly realized that our ideas could easily expand the project, with numerous functionality and features, that would bring the project to a far more complex level. We mapped all our ideas and prioritised them - and finally made a selection of ideas, which we planned on implementing.

The selected ideas included that:
\begin{itemize}
\item Users should be able add, delete and modify policies.
\item Users should be able to use complex operators in policies.
\item Users should be able to create nested rules in policies.
\item Users should be able to user wild-card in a policy (effecting for instance an entire floor without the \item need to specify the rooms that belong to the chosen floor).
\item Users should be able to save policies and easily toggle an ON or OFF state.
\item Users should be able to combine multiple sensors in a single policy.
\end{itemize}

The ideas were broken into three main front-end sites\footnote{Front-end "sites" are dynamic HTML website.}, from where the user can control the policy engine and overlook its operation.

Listing already existing and active policies:
\begin{enumerate}
\item A site where a user can create, delete or modify -policies.
\item A site that visual represent the building digitally with floor and rooms (like a map).
\item A site that indicate sensor values and group them in regards to the individual room they represent.
\end{enumerate}



\subsection{Sketch-up-s drawings of original ideas}

	Sketch-up's drawings of original ideas.
	Final visual interface
	

\subsection{Usability}
Seeing policies as rules for rooms in a building, with multiple sensors in each and every room, that can affect multi actuators not only in one room but all the rooms in a building: leaves the user with a lot of selections. Which if not represented properly complex the process of adding new policies.
Following the principles of Steve Krug's "Don't Make Me Think: Common Sense Approach to the Web"\cite{Krug:2005:DMM:1051204}, the functionality of a website should always let users accomplish their intended tasks as easy and directly as possible. Throughout the development of the front-end sites we have thrived to do so.
As an example we have designed the process of adding new policies as stepwise selections instead of presenting the users with all the capabilities and elements at once. The task looks simpler and makes the flow of  "adding a new policy" process more easy and direct.

[insert image of step]

Another approach towards usability was using web elements like: selectors and buttons, instead of having textual policies and forcing users to write policy using their keyboard.
For a developer textual editing and console commands might be preferred and somewhat quicker while they might know the inputs by heart. However the intended users of our policy engine are most likely not developers or fans of typing commands. Also it forces users to memorize the inputs, which might not be ideal for the client. Hence the idea was discarded and visual elements was implemented.
As for a future version of the policy engine, both methods could be implemented to function in parallel, giving the user both choices and the capability of copying and pasting policies quickly.


\subsection{Technology Choices}
Why Java, benefits? due to policy engine with object classes etc. Original plan to use PHP expected it to be simple to use Java classed to handle the policies.
